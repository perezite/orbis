TODO:
- RenderBatching aus Sandbox heraus bootstrappen
	- Sukkzessive die Klassenstruktur bootstrappen in Bootbox als v2-Klassen. Dabei regelmässig Regressionstest der Performance durchführen.
		- Shader		
			- Shaderliste im VideoManager verwalten
		- Texture		
			- Textureliste im VideoManager verwalten	
		- Material
		- Camera
		- Component
		- SpriteRenderer		
		- Rectangle Renderer
		- LineRenderer
		-- Die Bootbox-Klasse repräsentiert im Prinzip das Level
	- Wenn alles fertig implementiert ist: 
		- Die v2-Klassen in die originalen Klassen übertragen 
		- Die v2-Klassen löschen
		- Neue Klassenstruktur mit vorhandenen Levels 1-3 ausprobieren, inkl. Regressionstest der Performance
	- Branch zurückmergen auf master	
	-- Das Ziel ist: Rendern von 1000 Sprites auf dem Bildschirm. Die Sprites teilen sich auf in 10 Batches. Die Framerate liegt bei ca. 60 FPs auf dem Xperia. 
	-- Code-Inspiration: C:\Users\simon_000\Google Drive\docs\Indie\Bildung\Code Android NDK Beginners Guide Second Edition\Chapter 6\DroidBlaster -> DroidBlaster, GraphicsManager, SpriteBAtch, Sprite, 
- Math-Klassen zu structs machen
- Analysieren, ob weiter Klassen zu structs gemacht werden können	
- Gegebenenfalls Performance-Analyse durchführen
	- Level mit 10 Blocks befüllen
	- Performance-Analyse mit Funktions-Switching
	- Stopwatch-Klasse schreiben
	- Performance-Bottleneck mittels Stopwatch Timing isolieren
	- Falls das auch nicht hilft: Sandbox schreiben 
		- Freies ausprobieren:
			- Rendering gemäss Buch auf Amazon (mit VAO's)
			- Rendering gemäss http://androidblog.reindustries.com/a-real-opengl-es-2-0-2d-tutorial-part-7-texture-atlas/ (auch mit VAO's)
			- Andere Ideen
- Texture Atlas implementieren
	- Mesh Offsets etc. buffern (siehe RenderDevice::Render)
	- Beide Shader gleichschalten, so dass sie die gleichen Uniforms verwenden (selbst wenn diese nicht verwendet werden)
	- Packing-Algorithmus direkt im Level implementieren mithilfe graphischer Darstellung
		-- Referenz: https://www.youtube.com/watch?v=rVp5--Gx6Ks
	- Texture Atlas Klasse implementieren
		- AddRange Methode implementieren, welche mehrere Textures hinzufügt
		- Generate Methode implementieren, welche den Atlas berechnet. Dazu die vorher geschrieben Logik verwenden
		- Die Texture-Klasse so umschreiben, dass sie ggf. den SpriteAtlas verwendet zu dem sie hinzugefügt wurde.
	- RenderDevice anpassen, so dass pro TextureAtlas nur ein einziger DrawCall ausgeführt wird
	- Texture Atlassing in Level1 einbinden  
- Logik in SpriteRenderer und RectangleRenderer fixen (aktuell wird bei jeder Instanz der VBO neu gesetzt mit den immer gleichen Daten)
- Coroutinen implementieren
- Partikelsystem implementieren
- Asset-Funktionalität implementieren für Meshes, Shaders und Texturen (kontrollierte Erzeugung/Vernichtung)
	- Besserer Vorschlag: Alle Grafikrelevanten Ressourcen vom VideoManager verwalten lassen
- Orbis in Bibliothek versiegeln