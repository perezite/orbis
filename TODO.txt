TODO:	
- Refactoring
	- Renderer refactoren
		- Sukzessive den refactoreden Code hinzufügen und mittels Profiling potentielle Bottlenecks evaulieren
			- Rollback bis zum Branch '57b75b5'
			- RenderDevice::render() Performance messen ohne Änderungen, Performance messen und archivieren
			- Sukzessive Änderungen hinzufügen, Performance messen und archivieren und verifizieren, dass die Laufzeit von RenderDevice::render gleich bleibt
			-- Aktueller Stand:
				-- Man muss die Applikation auf 'Power saving' stellen in ATI, damit das Profiling verlässlichere Werte liefert
				-- Das Bottleneck ist die Funktion orb::RenderDevice::render (bzw. darin ausgeführte). Ich habe das rausgefunden indem ich die letzte Version profiled habe, und dort orb::RenderDevice::render ca. 8% Prozent mehr Zeit frisst.
				-- Das Ziel muss es also sein, alle Refactorings wiederherzustellen, ohne dass orb::RenderDevice::render langsamer wird
				-- Ich habe bereits das erste Refactoring durchgeführt (auslagern der Groupfunktion).
				-- Aktuell braucht RenderDevice::render 78.94%, vor dem Refactoring im vorigen Punkt 78.81%
				-- Das Ziel muss es also sein, dass RenderDevice::render nicht merh als ca. 79% frisst
			- Sobald der Code performant funktioniert: Temporär wegkopieren, Head auschecken, Code wieder reinkopieren, Push
		- Code-Styling überdenken (js-style vs a-style)
	- Angleich an SFML planen
	- Testing-Konzept überlegen (aktuell gibt es diverse Testing-Levels)
- Infrastruktur: Xperia Hard-reset
- Testing auf Real-Mobile
- Infastruktur: Ermitteln, welche Prozesse VS blocken (Kandidat: vcpkgsrv.exe) und Lösung dafür finden
	-- Hint: https://forums.unrealengine.com/development-discussion/c-gameplay-programming/25831-visual-studio-2013-express-vcpkgsrv-exe-going-crazy
- Evaluieren, ob weitere Refactorings nötig sind
- Testen auf Mobile
- Branch mergen		
- Partikelsystem implementieren
	- Fürs erste fixe Werte implementieren, welche der CenterPropulsion des Balles aus Blear entsprechen:
		- ColorOverLifetime (vorerst nicht als Gradient, sondern als Tween implementieren mit y-Achse = Alphawert)
	- Regression & Performanceregression
- Die CenterPropulsion des Balls aus Blear nachbauen. Dabei die Werte nach Bedarf tweaken
- Orbis in Bibliothek versiegeln
- Neues Projekt erstellen für die Implementation von Blear Level 1
- Orbis-Library als Submodule einbinden
- Folgende Element des Level1 von Blear implementieren in dieser Reihenfolge
	- Frame
	- Kollisionabfrage	
	- Ball 
	- Propulsion des Balles (nur CenterPropulsion)
	- Paddle
	- Bricks
	- Hintergrund
	- Levellogik mit Anzeigen über Console
	- Reset mit R-Taste