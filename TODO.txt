TODO:
- Rendering für Dynamische Vertices anpassen
	- Streamed Rendering mit GL_DYNAMIC_DRAW VBO's und Buffer Orphaning implementieren
		- Update mit Buffer Orphaning implementieren
	- v2 Funktionen aufräumen
	-- Referenz:
		- https://www.youtube.com/watch?v=2xWCvn9MZlg (ab 15:00): VBO update mit Buffer Orphaning
	-- Motivation: 
		-- Bisher halte ich die Vertices in einem statischen VBO und uploade die MVP-Matrix als ShaderUniform pro Sprite
		-- Für SpriteBatching kann ich kein ShaderUniform mehr verwenden für die MVP-Matrix, denn pro DrawCall wird der Wert unterschiedlich sein
		-- Die einzige Möglichkeit, die MVP-Matrix hochzuladen ist dann also, dass ich sie als ShaderAttribute für jeden Vertex setze, was viel zu viele Uploads gibt
		-- Die einzige logische Lösung aus meiner Sicht ist: Die Multiplikation MVP * Vertex auf der CPU machen und die Koordinaten dann pro Frame in ein dynamischs VBO hochladen
- RenderBatch implementieren (vorerst ohne Atlassing) 
	- RenderBatch-Klasse schreiben: Enthält Meshes, Material, Vertex und Index Offets
	- RenderDevice::FinalizeRendering umschreiben, so dass vor dem Erstellen des VBO und IBO die RenderBatches berechnet werden. In der Schleife wird dann ein Aufruf pro Batch gemacht
	- RenderDevice::RenderBatched erstellen, welches einen einzelnen Batch rendert
	- RenderDevice::RenderSingle löschen
- Texture Atlas implementieren
	- Mesh Offsets etc. buffern (siehe RenderDevice::Render)
	- Beide Shader gleichschalten, so dass sie die gleichen Uniforms verwenden (selbst wenn diese nicht verwendet werden)
	- Packing-Algorithmus direkt im Level implementieren mithilfe graphischer Darstellung
		-- Referenz: https://www.youtube.com/watch?v=rVp5--Gx6Ks
	- Texture Atlas Klasse implementieren
		- AddRange Methode implementieren, welche mehrere Textures hinzufügt
		- Generate Methode implementieren, welche den Atlas berechnet. Dazu die vorher geschrieben Logik verwenden
		- Die Texture-Klasse so umschreiben, dass sie ggf. den SpriteAtlas verwendet zu dem sie hinzugefügt wurde.
	- RenderDevice anpassen, so dass pro TextureAtlas nur ein einziger DrawCall ausgeführt wird
	- Texture Atlassing in Level1 einbinden  
- Logik in SpriteRenderer und RectangleRenderer fixen (aktuell wird bei jeder Instanz der VBO neu gesetzt mit den immer gleichen Daten)
- Coroutinen implementieren
- Partikelsystem implementieren
- Asset-Funktionalität implementieren für Meshes, Shaders und Texturen (kontrollierte Erzeugung/Vernichtung)
- Orbis in Bibliothek versiegeln