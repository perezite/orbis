TODO:
- Das rotierende Dreieck im Orbis-Style implementieren
	- Folgende Klassen der Reihe nach implementieren:
		- VideoManager
			- GraphicsAdapter mit VideoManager mergen
		- KeyCode
		- Event
		- EventAdapter mit InputManager mergen
		- InputManager
		- Entity
		- Level
		- LevelManager
		- Transform
		- Camera
		- Vector2D
		- SillyRenderer
			- Funktion hinzufügen dass man Farbe, Anzahl Vertices und gefüllt/nicht gefüllt anpassen kann
		- Level1
			- Rendert aktuell nur das Dreieck (rot, undurchsichtig, mit drei Ecken) mittels dem SillyRenderer
		- OrbisMain
			- windowWidth und windowHeight aus Konstruktor entfernen
			- Im Konstruktor automatisch die höchste verfügbare Auflösung auswählen
- Die ursprüngliche Orbis-Funktionalität re-implementieren für Windows und Android
		- Ant konfigurieren, dass es Assets aus einem zentralen Folder einbindet: http://stackoverflow.com/questions/16591482/how-do-you-specify-an-alternative-folder-to-the-asset-folder-at-build-time
		- Solution so einstellen, dass die Executables unter bin/Executables/<Platform> zu liegen kommen
		- Texturen verschieben nach bin/Assets/Textures
		- Die Assetpfade im Code anpassen
		- Texture
			- Effektiver Dateipfad für Laden des Files mittels IMG_Load wird direkt innerhalb der Klasse berechnet (vorerst)
				- Unter Windows wird der absolute Assetpfad mittels EnvironmentHelper::GetCurrentWorkingDirectory berechnet
				- Unter Android ist der angegebene relative Assetpfad bereits der zu verwendende Dateipfad
			-- Später sollte die Berechnung des Dateipfades bzw. das Laden des Bildes eventuell abstrahiert werden (zB. in eine Klasse Asset oder ImageAsset)
		- CameraController
		- SillyRenderer
		- SimpleController
		- TextureRenderer
		- Level1
		- Testen der Änderungen unter Windows und Android
- Feature-Branch orbis/cross-platform nach master mergen
- orbis.master Ordner wieder löschen